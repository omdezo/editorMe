:root {
  --bg-color: #000000;
  --text-color: #ffffff;
}

.hero-prism-container {
  position: relative;
  width: 100%;
  height: 100vh;
  background-color: var(--bg-color);
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
}

.prism-wrapper {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  z-index: 1;
}

.prism-layer {
  position: absolute;
  inset: -5%;
  /* Make slightly larger to avoid edge gaps on move */
  width: 110%;
  height: 110%;
  background-image: url('https://images.unsplash.com/photo-1550745165-9bc0b252726f?q=80&w=2670&auto=format&fit=crop');
  background-size: cover;
  background-position: center;
  mix-blend-mode: screen;
  /* The magic blend mode */
  opacity: 0.8;
  will-change: transform;
  transition: transform 0.1s cubic-bezier(0.1, 0.5, 0.5, 1);
}

/* 
   To create the RGB split effect on a color image:
   We can't easily isolate channels with just CSS blend modes on a single image.
   However, we can simulate it by tinting the layers or using a specific image style.
   
   Better approach for CSS-only RGB split:
   1. Use a B&W version of the image? No, we want color.
   2. Use the same image but apply color filters?
   
   Let's try a "Glitch" aesthetic where the layers are just copies.
   To make it look like RGB split, we can use `filter: drop-shadow` on the text,
   but for the image, moving 3 copies with `screen` blend mode creates a ghosting effect
   that looks very similar to chromatic aberration, especially if the image has high contrast.
*/

.layer-red {
  transform: translate(var(--red-x, 0), var(--red-y, 0));
  /* Tinting attempt */
  filter: sepia(100%) saturate(300%) hue-rotate(-50deg) opacity(0.6);
}

.layer-green {
  transform: translate(var(--green-x, 0), var(--green-y, 0));
  filter: sepia(100%) saturate(300%) hue-rotate(50deg) opacity(0.6);
}

.layer-blue {
  transform: translate(var(--blue-x, 0), var(--blue-y, 0));
  filter: sepia(100%) saturate(300%) hue-rotate(180deg) opacity(0.6);
}

/* Film Grain Overlay */
.film-grain {
  position: absolute;
  inset: 0;
  z-index: 5;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.15'/%3E%3C/svg%3E");
  opacity: 0.4;
  pointer-events: none;
  mix-blend-mode: overlay;
}

/* Typography */
.prism-content {
  position: relative;
  z-index: 20;
  text-align: center;
  /* Slight parallax on text */
  transform: translate(var(--text-x, 0), var(--text-y, 0));
  transition: transform 0.1s ease-out;
}

.prism-title {
  font-family: 'Inter', sans-serif;
  font-size: clamp(4rem, 12vw, 10rem);
  font-weight: 900;
  line-height: 0.9;
  color: #fff;
  margin: 0;
  letter-spacing: -0.04em;
  text-transform: uppercase;
  mix-blend-mode: overlay;
  /* Blend text with the chaos */

  /* Text RGB Split */
  text-shadow:
    calc(var(--red-x) * 0.5) calc(var(--red-y) * 0.5) 0 rgba(255, 0, 0, 0.7),
    calc(var(--blue-x) * 0.5) calc(var(--blue-y) * 0.5) 0 rgba(0, 0, 255, 0.7);
}

.prism-subtitle {
  font-family: monospace;
  font-size: 14px;
  letter-spacing: 8px;
  margin-top: 2rem;
  color: rgba(255, 255, 255, 0.8);
  text-transform: uppercase;
  text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
}

/* Vignette to focus center */
.vignette {
  position: absolute;
  inset: 0;
  background: radial-gradient(circle, transparent 30%, #000 120%);
  z-index: 10;
  pointer-events: none;
}

.scroll-indicator {
  position: absolute;
  bottom: 40px;
  left: 50%;
  transform: translateX(-50%);
  color: rgba(255, 255, 255, 0.5);
  font-family: monospace;
  font-size: 12px;
  letter-spacing: 3px;
  z-index: 20;
}

/* Responsive */
@media (max-width: 768px) {
  .prism-title {
    font-size: 15vw;
  }
}